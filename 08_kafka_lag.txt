================================================================================
                              KAFKA CONSUMER LAG
================================================================================

================================================================================
1. WHAT IS CONSUMER LAG?
================================================================================

DEFINITION:
    - Number of messages a consumer is behind the latest message
    - Difference between what's produced and what's consumed
    - Key health metric for Kafka consumers

FORMULA:
    Lag = Log End Offset (LEO) - Consumer Committed Offset

    Example:
        Log End Offset (latest):     1050
        Consumer Committed Offset:   1000
        Lag:                         50 messages

OFFSET TYPES:

    ┌─────────────────────────────────────────────────────────────────────┐
    │ Partition: [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12]  │
    │                          ↑                 ↑                  ↑    │
    │                    Committed          Current              Log End │
    │                     Offset         Position (next)         Offset  │
    │                                                                    │
    │                    Lag = 12 - 5 = 7 messages                       │
    └─────────────────────────────────────────────────────────────────────┘

    Log End Offset (LEO):
        - Offset of next message to be written
        - Highest offset in partition + 1
        - Controlled by producers

    High Watermark (HW):
        - Highest offset replicated to all ISR
        - Consumers can only read up to HW
        - Slightly behind LEO

    Committed Offset:
        - Last offset consumer confirmed processing
        - Stored in __consumer_offsets topic
        - Used for recovery after restart

WHY LAG MATTERS:

    1. Data Freshness:
       - High lag = stale data
       - Real-time systems need low lag

    2. Consumer Health:
       - Growing lag = consumer falling behind
       - May indicate processing issues

    3. Capacity Planning:
       - Persistent lag = need more consumers
       - Helps with scaling decisions

    4. SLA Compliance:
       - Many systems have latency requirements
       - Lag directly impacts end-to-end latency

================================================================================
2. MONITORING LAG
================================================================================

CLI COMMANDS:

    Describe Consumer Group:
        kafka-consumer-groups.sh --describe \
            --group <group-id> \
            --bootstrap-server localhost:9092

        Output:
        GROUP   TOPIC   PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG  CONSUMER-ID
        mygroup orders  0          1000            1050            50   consumer-1
        mygroup orders  1          2000            2000            0    consumer-1
        mygroup orders  2          1500            1600            100  consumer-2

    Check All Groups:
        kafka-consumer-groups.sh --describe \
            --all-groups \
            --bootstrap-server localhost:9092

    Check Group State:
        kafka-consumer-groups.sh --describe \
            --group <group-id> \
            --bootstrap-server localhost:9092 \
            --state

        States: Stable, Empty, Dead, PreparingRebalance, CompletingRebalance

    Get Topic Offsets (without consumer group):
        kafka-run-class.sh kafka.tools.GetOffsetShell \
            --broker-list localhost:9092 \
            --topic <topic-name>

JMX METRICS:

    Consumer Metrics (per partition):
        records-lag              - Current lag
        records-lag-max          - Maximum lag seen
        records-lag-avg          - Average lag

    Consumer Coordinator Metrics:
        commit-latency-avg       - Offset commit latency
        commit-latency-max       - Max commit latency
        commit-rate              - Commits per second

    Fetch Metrics:
        fetch-latency-avg        - Fetch request latency
        fetch-rate               - Fetches per second
        bytes-consumed-rate      - Consumption throughput

MONITORING TOOLS:

    Burrow (LinkedIn):
        - Dedicated lag monitoring
        - Consumer lag evaluation
        - Alerting based on lag trends

    Kafka Lag Exporter:
        - Prometheus metrics exporter
        - Works with Grafana dashboards
        - Kubernetes-friendly

    Confluent Control Center:
        - Commercial monitoring UI
        - Real-time lag visualization
        - Consumer group management

================================================================================
3. CAUSES OF LAG
================================================================================

CONSUMER-SIDE CAUSES:

    1. Slow Processing:
       - Processing time > arrival rate
       - Complex business logic
       - Blocking I/O operations
       - Database bottlenecks

    2. Insufficient Consumers:
       - Fewer consumers than partitions
       - Not enough parallelism
       - Underprovisioned resources

    3. Consumer Crashes:
       - Application failures
       - Out of memory errors
       - Unhandled exceptions

    4. Rebalancing:
       - Consumers stop during rebalance
       - Frequent rebalances compound lag
       - State rebuilding after rebalance

    5. GC Pauses:
       - Long garbage collection
       - Causes missed heartbeats
       - May trigger rebalance

PRODUCER-SIDE CAUSES:

    6. Traffic Spikes:
       - Sudden increase in production rate
       - Burst traffic patterns
       - Batch uploads

    7. Backfill Operations:
       - Historical data loads
       - Replay events
       - Migration activities

INFRASTRUCTURE CAUSES:

    8. Network Issues:
       - High latency between consumer and broker
       - Network congestion
       - Cross-datacenter consumption

    9. Broker Issues:
       - Overloaded brokers
       - Disk I/O bottlenecks
       - Under-replicated partitions

    10. Resource Constraints:
        - CPU saturation
        - Memory pressure
        - Disk full

================================================================================
4. LAG ANALYSIS
================================================================================

HEALTHY vs UNHEALTHY LAG:

    Healthy (Transient):
        - Lag increases temporarily
        - Returns to near-zero
        - Follows traffic patterns
        - Example: Brief spike during peak hours

    Unhealthy (Persistent):
        - Lag grows continuously
        - Never catches up
        - Indicates capacity problem
        - Example: Lag increasing hour over hour

LAG PATTERNS:

    Pattern 1: Sawtooth
        ┌─────────────────────────────────────┐
        │    /\    /\    /\    /\            │
        │   /  \  /  \  /  \  /  \           │
        │  /    \/    \/    \/    \          │
        └─────────────────────────────────────┘
        Cause: Batch processing, periodic commits
        Action: Usually normal, monitor amplitude

    Pattern 2: Growing
        ┌─────────────────────────────────────┐
        │                            ____/    │
        │                      ____/          │
        │                ____/                │
        │          ____/                      │
        │    ____/                            │
        └─────────────────────────────────────┘
        Cause: Consumer can't keep up
        Action: Scale consumers, optimize processing

    Pattern 3: Spike then Recovery
        ┌─────────────────────────────────────┐
        │         /\                          │
        │        /  \                         │
        │       /    \____                    │
        │ _____/          \____               │
        └─────────────────────────────────────┘
        Cause: Traffic burst, temporary slowdown
        Action: Usually self-resolving

    Pattern 4: Step Function
        ┌─────────────────────────────────────┐
        │                    _______________  │
        │                   |                 │
        │          ________|                  │
        │         |                           │
        │ ________|                           │
        └─────────────────────────────────────┘
        Cause: Consumer died, partition reassigned
        Action: Investigate consumer health

CALCULATING LAG RATE:

    Lag Rate = (Current Lag - Previous Lag) / Time Interval

    Positive rate: Falling behind
    Zero rate: Keeping up
    Negative rate: Catching up

    Example:
        T0: Lag = 1000
        T1 (1 min later): Lag = 1500
        Lag Rate = (1500 - 1000) / 60 = 8.3 messages/second behind

================================================================================
5. REDUCING LAG
================================================================================

SCALE CONSUMERS:

    1. Add More Consumer Instances:
       - Maximum parallelism = partition count
       - Each partition consumed by one consumer
       - No benefit beyond partition count

       Before (3 consumers, 6 partitions):
           C1: [P0, P1]  C2: [P2, P3]  C3: [P4, P5]

       After (6 consumers, 6 partitions):
           C1: [P0]  C2: [P1]  C3: [P2]  C4: [P3]  C5: [P4]  C6: [P5]

    2. Increase Partitions:
       - More partitions = more parallelism
       - Requires topic alteration
       - Note: Cannot decrease partitions

       kafka-topics.sh --alter \
           --topic orders \
           --partitions 12 \
           --bootstrap-server localhost:9092

OPTIMIZE PROCESSING:

    3. Batch Operations:
       - Batch database writes
       - Batch API calls
       - Reduce per-record overhead

    4. Async Processing:
       - Non-blocking I/O
       - Parallel processing threads
       - Use pause/resume for backpressure

    5. Reduce Processing Complexity:
       - Profile and optimize hot paths
       - Cache frequently accessed data
       - Simplify business logic

TUNE CONSUMER CONFIGURATION:

    6. Increase Fetch Size:
       fetch.max.bytes=52428800        # 50MB
       max.partition.fetch.bytes=1048576  # 1MB per partition

    7. Increase Poll Batch:
       max.poll.records=1000           # More records per poll

    8. Tune Poll Interval:
       max.poll.interval.ms=600000     # Allow longer processing

    9. Optimize Commit Strategy:
       - Commit less frequently
       - Use async commits
       - Commit after batch, not per record

ADDRESS ROOT CAUSES:

    10. Fix Slow Dependencies:
        - Database query optimization
        - Connection pooling
        - Caching layer

    11. Resolve Network Issues:
        - Co-locate consumers with brokers
        - Increase network bandwidth
        - Reduce cross-datacenter traffic

    12. Upgrade Resources:
        - More CPU cores
        - More memory
        - Faster disks

================================================================================
6. LAG ALERTING
================================================================================

ALERT THRESHOLDS:

    Absolute Lag:
        - Warning: Lag > 10,000 messages
        - Critical: Lag > 100,000 messages
        - Adjust based on your SLAs

    Lag Duration:
        - Warning: Lag > 5 minutes of data
        - Critical: Lag > 15 minutes of data
        - Based on production rate

    Lag Trend:
        - Warning: Lag growing for > 10 minutes
        - Critical: Lag growing for > 30 minutes
        - Catches persistent issues

ALERT EXAMPLES (Prometheus):

    High Lag:
        alert: KafkaConsumerLagHigh
        expr: kafka_consumer_group_lag > 10000
        for: 5m
        labels:
          severity: warning

    Growing Lag:
        alert: KafkaConsumerLagGrowing
        expr: rate(kafka_consumer_group_lag[5m]) > 0
        for: 15m
        labels:
          severity: warning

    Consumer Stopped:
        alert: KafkaConsumerStopped
        expr: kafka_consumer_group_members == 0
        for: 2m
        labels:
          severity: critical

BEST PRACTICES:

    1. Alert on Trends, Not Just Values:
       - Temporary spikes are often normal
       - Persistent growth is concerning

    2. Set Context-Appropriate Thresholds:
       - Real-time systems: tight thresholds
       - Batch systems: relaxed thresholds

    3. Include Consumer Group in Alerts:
       - Different groups have different SLAs
       - Avoid one-size-fits-all

    4. Have Runbooks:
       - Document remediation steps
       - Include escalation paths

================================================================================
7. LAG DURING INCIDENTS
================================================================================

CONSUMER FAILURE:

    Scenario: Consumer crashes
    Impact: Partitions reassigned, lag grows during rebalance

    Recovery Steps:
        1. Identify failed consumer (logs, monitoring)
        2. Fix root cause (OOM, exception, etc.)
        3. Restart consumer
        4. Monitor lag recovery

REBALANCE STORM:

    Scenario: Frequent rebalances causing lag

    Mitigation:
        1. Use CooperativeStickyAssignor
        2. Enable static membership (group.instance.id)
        3. Tune session.timeout.ms (longer for stability)
        4. Investigate rebalance triggers

TRAFFIC SPIKE:

    Scenario: Sudden increase in production rate

    Response:
        1. Accept temporary lag increase
        2. Verify consumers are healthy
        3. Scale consumers if lag persists
        4. Consider rate limiting producers

CATCHUP AFTER OUTAGE:

    Scenario: Consumers were down, now have large lag

    Options:
        1. Wait for Natural Catchup:
           - If lag is recoverable
           - Monitor progress

        2. Scale Temporarily:
           - Add consumers for catchup
           - Remove after lag clears

        3. Skip Old Data:
           - Reset offsets to latest
           - Only for non-critical data
           kafka-consumer-groups.sh --reset-offsets \
               --to-latest --execute

        4. Parallel Catchup:
           - Process old and new data separately
           - Merge after catchup

================================================================================
QUICK REFERENCE
================================================================================

LAG FORMULA:
    Lag = Log End Offset - Committed Offset

CLI COMMANDS:
    kafka-consumer-groups.sh --describe --group <id> ...
    kafka-consumer-groups.sh --describe --all-groups ...
    kafka-consumer-groups.sh --reset-offsets --to-latest ...

COMMON CAUSES:
    - Slow processing
    - Insufficient consumers
    - Rebalancing
    - Traffic spikes
    - Network/broker issues

SOLUTIONS:
    - Scale consumers (up to partition count)
    - Increase partitions
    - Optimize processing (batch, async)
    - Tune fetch/poll configuration
    - Fix slow dependencies

KEY METRICS:
    - records-lag (per partition)
    - records-lag-max
    - Lag rate (change over time)

ALERT GUIDELINES:
    - Alert on trends, not just absolute values
    - Set context-appropriate thresholds
    - Include consumer group context
    - Have documented runbooks

================================================================================
